Tarefa 03: Refatorar Serviço de Contrato (Método Alternativo)
Objetivo: Modificar o contractService.ts para parar de depender de um token de sessão (que não existe mais) e, em vez disso, buscar os dados usando o id_cliente (obtido no login) como filtro.

Contexto: Esta tarefa é uma continuação da refatoração do "Método Alternativo" (Tarefas 01 e 02). O AuthContext agora armazena o id_cliente do usuário logado.

1. Modificação em constants/config.ts
O endpoint /cliente_contrato já deve ter sido adicionado na Tarefa 01 (login) e 02 (faturas), mas vamos garantir que ele exista no IXC_CONFIG.ENDPOINTS.

TypeScript

// Em: constants/config.ts

export const IXC_CONFIG = {
  // ... (BASE_URL, TOKEN)
  ENDPOINTS: {
    CLIENTE: '/cliente', 
    CONTRATO: '/cliente_contrato', // Endpoint que será usado
    FN_ARECEBER: '/fn_areceber', 
    GET_BOLETO: '/get_boleto',
    // ...
  }
};
2. Modificação em types/ixc.ts
Já devemos ter os tipos de contrato da Tarefa 01, mas vamos garantir que o contractService tenha o que precisa.

TypeScript

// Em: types/ixc.ts

// (Manter os tipos existentes: AuthUserData, IXCFaturaResponse, etc...)

// Tipo para a resposta de /cliente_contrato
export interface IXCContrato {
  id: string;
  id_cliente: string;
  status: string; // "Ativo", "Bloqueado", "Cancelado"
  descricao_aux_plano_venda: string; // Nome do Plano
  data_ativacao: string;
  // ... adicione outros campos do contrato que a tela de perfil precisa
}

export interface IXCContratoResponse {
  total: number;
  registros: IXCContrato[];
}
3. Modificação em services/contractService.ts
Este é o ficheiro principal da tarefa. Vamos reescrevê-lo para usar o id_cliente como filtro.

TypeScript

// Em: services/contractService.ts
import { ixcApi } from './ixcApi';
import { IXC_CONFIG } from '@/constants/config';
import type { 
  IXCContrato,
  IXCContratoResponse 
} from '@/types/ixc';

export const contractService = {

  /**
   * Busca os contratos de um cliente específico.
   * (Método Alternativo: usa /cliente_contrato com id_cliente)
   */
  async getContracts(idCliente: string): Promise<IXCContrato[]> {
    try {
      // 1. Prepara o corpo da requisição (JSON de pesquisa)
      const requestBody = {
        qtype: 'cliente_contrato.id_cliente',
        query: idCliente, // Filtra pelo ID do cliente logado
        oper: '=',
        page: '1',
        rp: '10', // Pega os últimos 10 contratos
        sortname: 'cliente_contrato.id',
        sortorder: 'desc',
      };

      // 2. Chama o 'postList' (com header 'ixcsoft: listar')
      // (Assume que o ixcApi.ts já foi modificado na Tarefa 02)
      const response = await ixcApi.postList<IXCContratoResponse>(
        IXC_CONFIG.ENDPOINTS.CONTRATO,
        requestBody
      );

      if (response.total > 0) {
        return response.registros;
      }
      
      return []; // Retorna lista vazia se não houver contratos

    } catch (error) {
      console.error('Erro ao buscar contratos:', error);
      throw new Error('Não foi possível carregar os contratos.');
    }
  },

  /**
   * Busca um contrato específico pelo ID do contrato.
   */
  async getContractById(idContrato: string): Promise<IXCContrato | null> {
    try {
      const requestBody = {
        qtype: 'cliente_contrato.id',
        query: idContrato,
        oper: '=',
        page: '1',
        rp: '1',
        sortname: 'cliente_contrato.id',
        sortorder: 'asc',
      };

      const response = await ixcApi.postList<IXCContratoResponse>(
        IXC_CONFIG.ENDPOINTS.CONTRATO,
        requestBody
      );

      if (response.total > 0 && response.registros[0]) {
        return response.registros[0];
      }
      
      return null;

    } catch (error) {
      console.error('Erro ao buscar contrato pelo ID:', error);
      throw new Error('Não foi possível carregar o contrato.');
    }
  }
};