Entendido. Se o endpoint /login está descartado, vamos reestruturar o aplicativo para usar a alternativa (o endpoint /cliente com o ID_cliente).

Como você pediu, aqui está o "prompt" (a tarefa) detalhado no formato dos seus modelos (01.md, 02.md, etc.), detalhando as modificações necessárias para fazer essa "alternativa" funcionar.

Tarefa: Refatorar o Fluxo de Autenticação (Usar /cliente)
Objetivo: Alterar a arquitetura de autenticação do AplicativoFIber para parar de usar o endpoint /login (que está bloqueado) e implementar a "alternativa" (Pesquisa no /cliente) conforme instruído pelo suporte do IXC.

Contexto: O endpoint /login não está disponível (Recurso login não está disponível!). A única solução é usar o endpoint /cliente (Listar), que, na sua configuração, retorna a senha em texto puro, permitindo a validação no lado do aplicativo.

Desafio Principal: O endpoint /cliente não retorna um Token de Sessão (JWT). O aplicativo (ixcApi.ts, AuthContext.tsx) foi construído para usar um token de sessão em todas as chamadas (faturas, contratos, etc.).

Solução: Vamos refatorar o aplicativo para não usar mais tokens de sessão.

O Login (no authService.ts) vai pesquisar no /cliente para validar a senha.

Se a senha for válida, vamos guardar o id (ID do Cliente) e o id_contrato no AuthContext.

Todas as outras chamadas de API (faturas, contratos, etc.) serão modificadas para usar o Token de Admin (do IXC_CONFIG.TOKEN) + o id_cliente/id_contrato como filtro, em vez de um token de sessão.

Requisitos Técnicos e Modificações
1. constants/config.ts
O IXC_CONFIG precisa ser atualizado para incluir o endpoint /cliente e /cliente_contrato.

TypeScript

// constants/config.ts

export const IXC_CONFIG = {
  BASE_URL: 'https://centralfiber.online/webservice/v1',
  TOKEN: 'SEU_TOKEN_DE_ADMIN_AQUI', // O token da imagem (Carlos Eduardo)
  
  ENDPOINTS: {
    // LOGIN: '/login', // Não será mais usado
    CLIENTE: '/cliente', // Endpoint de Pesquisa/Listar
    CONTRATO: '/cliente_contrato' // Para buscar o contrato após o login
    FATURAS: '/fn_areacliente_faturas',
    SUPORTE: '/su_oss_chamado',
  }
};

// ... (Resto do arquivo, GENIE_ACS_CONFIG, etc.)
2. types/ixc.ts
O tipo IXCAuthResponse está obsoleto, pois não receberemos mais um token. Precisamos de novos tipos para o AuthContext.

TypeScript

// types/ixc.ts

// (Tipo antigo - não será mais usado diretamente pelo login)
export interface IXCAuthResponse {
  token: string;
  id_contrato: number;
  nome_cliente: string;
  // ...
}

// (Novo Tipo - O que o AuthContext vai guardar agora)
export interface AuthUserData {
  id_cliente: string;
  id_contrato: string;
  nome_cliente: string;
  email: string;
  telefone: string;
  status_contrato: string; 
  // ... (adicione quaisquer outros dados do JSON de /cliente que você queira)
}

// (Novo Tipo - Para a resposta da pesquisa /cliente)
export interface IXCClienteRegistro {
  id: string;
  razao: string;
  hotsite_email: string;
  senha: string; // O campo inseguro que vamos validar
  telefone_celular: string;
  // ...
}

export interface IXCClienteResponse {
  total: number;
  registros: IXCClienteRegistro[];
}

// (Novo Tipo - Para a resposta do /cliente_contrato)
export interface IXCContratoRegistro {
  id: string;
  id_cliente: string;
  status: string; // "Ativo", "Bloqueado", etc.
  // ...
}

export interface IXCContratoResponse {
  total: number;
  registros: IXCContratoRegistro[];
}
3. services/ixcApi.ts
Este é o "motor" da API. Ele precisa ser modificado para parar de usar tokens de sessão e começar a enviar o header ixcsoft: listar em requisições de pesquisa.

TypeScript

// services/ixcApi.ts
import axios, { AxiosInstance, AxiosRequestConfig } from 'axios';
import { IXC_CONFIG } from '@/constants/config';

class IXCApiClient {
  private api: AxiosInstance;
  private adminToken: string; // Armazena o Token de Admin

  constructor() {
    // Pega o Token de Admin (o token 'Carlos Eduardo')
    this.adminToken = this.encodeToken(IXC_CONFIG.TOKEN);

    this.api = axios.create({
      baseURL: IXC_CONFIG.BASE_URL,
      headers: {
        'Content-Type': 'application/json',
        // O Token de Admin será o padrão para TODAS as requisições
        'Authorization': this.adminToken, 
      },
      timeout: 10000,
    });
  }

  // Codifica o Token de Admin (ex: "ID:TOKEN") para Base64
  private encodeToken(token: string): string {
    // Assumindo que seu token já está no formato ID:TOKEN
    // Se for só o token, ajuste aqui
    try {
      // No Node.js (backend) usa-se Buffer, no React Native é diferente
      // Vamos usar uma biblioteca ou método de Base64 (ex: 'react-native-base64')
      // Se você não tiver uma, instale: pnpm add react-native-base64
      const base64 = require('react-native-base64'); 
      return `Basic ${base64.encode(token)}`;
    } catch (e) {
      console.error("Falha ao codificar token. Instale 'react-native-base64'", e);
      return `Basic ${token}`; // Fallback inseguro
    }
  }

  // --- MODIFICADO: Não precisamos mais de setToken/clearToken ---
  // public setToken(token: string) { ... } // REMOVER
  // public clearToken() { ... } // REMOVER

  // (Método POST Padrão - para Criar/Editar)
  public post<T = any>(endpoint: string, data: any): Promise<T> {
    return this.api.post(endpoint, data).then(res => res.data);
  }

  // (Novo Método POST para Listar/Pesquisar)
  public postList<T = any>(endpoint: string, data: any): Promise<T> {
    const config: AxiosRequestConfig = {
      headers: {
        'ixcsoft': 'listar' // Header especial para pesquisa
      }
    };
    return this.api.post(endpoint, data, config).then(res => res.data);
  }
}

export const ixcApi = new IXCApiClient();
4. services/authService.ts
Reescrever completamente a função login para usar a nova alternativa.

TypeScript

// services/authService.ts
import { ixcApi } from './ixcApi';
import { IXC_CONFIG } from '@/constants/config';
import type { 
  IXCLoginRequest, 
  AuthUserData, 
  IXCClienteResponse,
  IXCContratoResponse
} from '@/types/ixc';

export const authService = {
  
  async login(credentials: IXCLoginRequest): Promise<AuthUserData> {
    try {
      // --- PASSO 1: PESQUISAR O CLIENTE POR E-MAIL/CPF ---
      // (Usando o login do usuário, que pode ser e-mail ou CPF)
      const campoBusca = credentials.login.includes('@') 
        ? 'cliente.hotsite_email' 
        : 'cliente.cnpj_cpf';

      const searchBody = {
        qtype: campoBusca,
        query: credentials.login,
        oper: '=',
        page: '1',
        rp: '1', // Só queremos 1 resultado
        sortname: 'cliente.id',
        sortorder: 'asc',
      };

      // Usamos o novo 'postList' para pesquisar no /cliente
      const clienteResponse = await ixcApi.postList<IXCClienteResponse>(
        IXC_CONFIG.ENDPOINTS.CLIENTE,
        searchBody
      );

      // Cliente não encontrado pelo e-mail/CPF
      if (clienteResponse.total === 0 || !clienteResponse.registros[0]) {
        throw new Error('Usuário ou senha inválidos');
      }

      const cliente = clienteResponse.registros[0];

      // --- PASSO 2: VALIDAR A SENHA (Inseguro, mas é a alternativa) ---
      // Comparamos a senha digitada com a senha em texto puro que veio da API
      if (cliente.senha !== credentials.senha) {
        throw new Error('Usuário ou senha inválidos');
      }

      // --- PASSO 3: BUSCAR O CONTRATO (Chamada Adicional) ---
      // O App precisa do id_contrato e do status_contrato
      const contratoBody = {
        qtype: 'cliente_contrato.id_cliente',
        query: cliente.id, // Usamos o ID do cliente que acabamos de validar
        oper: '=',
        page: '1',
        rp: '1', // Pegamos o primeiro contrato ativo
        sortname: 'cliente_contrato.id',
        sortorder: 'desc',
      };

      const contratoResponse = await ixcApi.postList<IXCContratoResponse>(
        IXC_CONFIG.ENDPOINTS.CONTRATO,
        contratoBody
      );

      if (contratoResponse.total === 0 || !contratoResponse.registros[0]) {
        throw new Error('Cliente validado, mas nenhum contrato encontrado.');
      }
      
      const contrato = contratoResponse.registros[0];

      // --- PASSO 4: MONTAR A RESPOSTA PARA O APP ---
      // O objeto que o AuthContext vai armazenar
      const userData: AuthUserData = {
        id_cliente: cliente.id,
        id_contrato: contrato.id,
        nome_cliente: cliente.razao,
        email: cliente.hotsite_email,
        telefone: cliente.telefone_celular,
        status_contrato: contrato.status, 
      };

      // Não há token de sessão para salvar
      // ixcApi.setToken( ... ) // REMOVIDO

      return userData;

    } catch (error) {
      if (error instanceof Error) {
        throw new Error(`Erro no login: ${error.message}`);
      }
      throw new Error('Erro desconhecido ao fazer login');
    }
  },

  logout() {
    // Não há token de sessão para limpar
    // ixcApi.clearToken(); // REMOVIDO
  },
  
  // ... (função mockLogin pode ser mantida para testes)
};
5. contexts/AuthContext.tsx (e outros serviços)
AuthContext.tsx: Você deve modificar o estado user para armazenar AuthUserData | null (o novo tipo que criámos) em vez de IXCAuthResponse | null. A função signIn vai funcionar, pois o authService.login agora retorna o objeto AuthUserData.

invoiceService.ts e contractService.ts: Estes serviços precisam ser reescritos.

Eles não podem mais fazer chamadas diretas.

Eles precisam de receber o id_cliente ou id_contrato (que está guardado no AuthContext).

Eles devem usar o ixcApi.postList (com o header ixcsoft: listar) e adicionar um grid_param para filtrar os resultados pelo id_cliente ou id_contrato do usuário logado.