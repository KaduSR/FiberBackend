Aqui está o prompt (a tarefa) para a correção e implementação final da alternativa de autenticação, seguindo o seu modelo.

Tarefa 04: Refatoração Final da Autenticação (Método Alternativo)
Contexto: O suporte do IXCSoft confirmou que o endpoint /login não pode ser liberado. A única alternativa viável é usar o endpoint /cliente (Listar) para validar o e-mail/senha e, em seguida, usar o id_cliente e id_contrato para todas as requisições futuras (faturas, contratos, etc.).

As tentativas anteriores de modificar o authService.ts (Tarefa 01) e o invoiceService.ts (Tarefa 02) causaram erros de TypeScript, pois a arquitetura do aplicativo (baseada em token de sessão) é incompatível com a alternativa.

Tarefa: Refatorar todos os serviços IXC (ixcApi, authService, invoiceService, contractService) para implementar o "Método Alternativo" corretamente, corrigindo todos os erros de TypeScript e alinhando a arquitetura do aplicativo (AuthContext) com o novo fluxo de dados.

Requisitos Técnicos
1. Modificar constants/config.ts
O ficheiro de configuração deve ser atualizado para exportar objetos (como o authService.ts espera) e incluir todos os endpoints que vamos usar.

TypeScript

// Em: constants/config.ts

// O Token de Admin (do seu usuário 'Carlos Eduardo')
// DEVE estar no formato "ID_DO_USUARIO:TOKEN_STRING"
const IXC_ADMIN_TOKEN = 'SEU_ID_USUARIO_API:SEU_TOKEN_API';

// 1. Configuração do IXC
export const IXC_CONFIG = {
  BASE_URL: 'https://centralfiber.online/webservice/v1',
  TOKEN: IXC_ADMIN_TOKEN, // Usar o Token de Admin aqui
  
  ENDPOINTS: {
    // LOGIN: '/login', // Não usado
    CLIENTE: '/cliente',
    CONTRATO: '/cliente_contrato',
    FN_ARECEBER: '/fn_areceber',
    GET_BOLETO: '/get_boleto'
    // ... adicione outros aqui
  }
};

// 2. Configuração do Backend (Render)
const BACKEND_URL = 'https://api.centralfiber.online'; // Use a sua URL do Render

export const GENIE_ACS_CONFIG = {
  BASE_URL: `${BACKEND_URL}/api/ont`
};
// ... (outros configs do backend)
2. Modificar types/ixc.ts
Atualizar os tipos para refletir o novo fluxo (sem token de sessão, mas com id_cliente).

TypeScript

// Em: types/ixc.ts

// ... (IXCLoginRequest permanece o mesmo)

// Este é o objeto que o AuthContext vai guardar
export interface AuthUserData {
  id_cliente: string;
  id_contrato: string;
  nome_cliente: string;
  email: string;
  telefone: string;
  status_contrato: 'Ativo' | 'Vencido' | 'Bloqueado' | 'Cancelado' | 'Outro'; // Corrigido
}

// Resposta da pesquisa /cliente
export interface IXCClienteRegistro {
  id: string;
  razao: string;
  hotsite_email: string;
  senha: string; // O campo inseguro que vamos validar
  telefone_celular: string;
  // ...
}
export interface IXCClienteResponse {
  total: number;
  registros: IXCClienteRegistro[];
}

// Resposta da pesquisa /cliente_contrato
export interface IXCContratoRegistro {
  id: string;
  id_cliente: string;
  status: string; // A API retorna o status como string
  // ...
}
export interface IXCContratoResponse {
  total: number;
  registros: IXCContratoRegistro[];
}

// Resposta de Faturas /fn_areceber
export interface IXCFatura {
  id: string;
  id_cliente: string;
  data_vencimento: string;
  valor: string;
  status: 'A' | 'B'; // A = Aberto, B = Baixado
  linha_digitavel: string;
}
export interface IXCFaturaResponse {
  total: number;
  registros: IXCFatura[];
}

// Pedido para /get_boleto
export interface IXCBoletoRequest {
  boletos: string;
  atualiza_boleto: 'S';
  tipo_boleto: 'arquivo';
  base64: 'S';
}
// Resposta de /get_boleto
export interface IXCBoletoResponse {
  file: string;
}
3. Modificar services/ixcApi.ts
Corrigir o ixcApi.ts para parar de usar tokens de sessão e para enviar corretamente o header ixcsoft: listar.

TypeScript

// Em: services/ixcApi.ts
import axios, { AxiosInstance, AxiosRequestConfig } from 'axios';
import { IXC_CONFIG } from '@/constants/config';
// Instale 'react-native-base64' se ainda não o fez: pnpm add react-native-base64
import base64 from 'react-native-base64'; 

class IXCApiClient {
  private api: AxiosInstance;
  private adminToken: string;

  constructor() {
    // Codifica o Token de Admin (Formato: "ID:TOKEN_STRING")
    try {
      this.adminToken = `Basic ${base64.encode(IXC_CONFIG.TOKEN)}`;
    } catch (e) {
      console.error("Falha ao codificar token.", e);
      this.adminToken = `Basic ${IXC_CONFIG.TOKEN}`;
    }

    this.api = axios.create({
      baseURL: IXC_CONFIG.BASE_URL,
      headers: {
        'Content-Type': 'application/json',
        // O Token de Admin é o padrão para TODAS as requisições
        'Authorization': this.adminToken, 
      },
      timeout: 10000,
    });
  }

  // (REMOVIDO) setToken e clearToken não são mais necessários
  
  // POST Padrão (para Criar/Editar/Get_Boleto)
  public async post<T = any>(endpoint: string, data: any): Promise<T> {
    const response = await this.api.post(endpoint, data);
    return response.data;
  }

  // (MODIFICADO) POST para Listar/Pesquisar
  // (Corrige o erro "1-2 argumentos eram esperados, mas 3 foram obtidos")
  public async postList<T = any>(endpoint: string, data: any): Promise<T> {
    const config: AxiosRequestConfig = {
      headers: {
        'ixcsoft': 'listar' // Header especial para pesquisa
      }
    };
    const response = await this.api.post(endpoint, data, config);
    return response.data;
  }
}

export const ixcApi = new IXCApiClient();
4. Modificar services/authService.ts
Reescrever a função login para usar o "Método Alternativo" e retornar os tipos corretos (corrigindo os erros de TS).

TypeScript

// Em: services/authService.ts
import { ixcApi } from './ixcApi';
import { IXC_CONFIG } from '@/constants/config';
import type { 
  IXCLoginRequest, 
  AuthUserData, 
  IXCClienteResponse,
  IXCContratoResponse
} from '@/types/ixc';

export const authService = {
  
  async login(credentials: IXCLoginRequest): Promise<AuthUserData> {
    try {
      // --- PASSO 1: PESQUISAR O CLIENTE ---
      const campoBusca = credentials.login.includes('@') 
        ? 'cliente.hotsite_email' 
        : 'cliente.cnpj_cpf';

      const searchBody = {
        qtype: campoBusca,
        query: credentials.login,
        oper: '=',
        page: '1', rp: '1',
        sortname: 'cliente.id', sortorder: 'asc',
      };

      const clienteResponse = await ixcApi.postList<IXCClienteResponse>(
        IXC_CONFIG.ENDPOINTS.CLIENTE,
        searchBody
      );

      if (clienteResponse.total === 0 || !clienteResponse.registros[0]) {
        throw new Error('Usuário ou senha inválidos (C1)');
      }

      const cliente = clienteResponse.registros[0];

      // --- PASSO 2: VALIDAR A SENHA (Método Inseguro) ---
      if (cliente.senha !== credentials.senha) {
        throw new Error('Usuário ou senha inválidos (C2)');
      }

      // --- PASSO 3: BUSCAR O CONTRATO (Chamada Adicional) ---
      const contratoBody = {
        qtype: 'cliente_contrato.id_cliente',
        query: cliente.id,
        oper: '=',
        page: '1', rp: '1',
        sortname: 'cliente_contrato.data_ativacao',
        sortorder: 'desc',
      };

      const contratoResponse = await ixcApi.postList<IXCContratoResponse>(
        IXC_CONFIG.ENDPOINTS.CONTRATO,
        contratoBody
      );

      if (contratoResponse.total === 0 || !contratoResponse.registros[0]) {
        throw new Error('Cliente validado, mas nenhum contrato encontrado.');
      }
      
      const contrato = contratoResponse.registros[0];

      // --- PASSO 4: MONTAR A RESPOSTA PARA O APP ---
      // (Corrige o erro "O tipo '""' não pode ser atribuído...")
      const userData: AuthUserData = {
        id_cliente: cliente.id,
        id_contrato: contrato.id,
        nome_cliente: cliente.razao,
        email: cliente.hotsite_email,
        telefone: cliente.telefone_celular,
        // Converte o status (string) para o tipo esperado
        status_contrato: (contrato.status as AuthUserData['status_contrato']) || 'Outro',
      };

      return userData;

    } catch (error) {
      // ... (código de erro)
    }
  },

  logout() {
    // Não há token de sessão para limpar
  },
  
  // (mockLogin - Corrigir o erro "deve retornar um valor")
  async mockLogin(email: string, senha: string): Promise<AuthUserData> {
    await new Promise(resolve => setTimeout(resolve, 1000));
    if (email === 'test@fibernet.com' && senha === '123456') {
      const mockResponse: AuthUserData = { // <--- Usar o novo tipo
        id_cliente: '123',
        id_contrato: '12345',
        nome_cliente: 'João Silva (Mock)',
        email: 'test@fibernet.com',
        telefone: '(11) 99999-9999',
        status_contrato: 'Ativo',
      };
      return mockResponse; // <--- Corrigido
    }
    throw new Error('E-mail ou senha inválidos');
  },
};
5. Modificar contexts/AuthContext.tsx
Atualizar o Context para guardar AuthUserData (com o id_cliente) em vez de IXCAuthResponse (com o token).

TypeScript

// Em: contexts/AuthContext.tsx
import React, { createContext, useState, useEffect, ReactNode } from 'react';
import { authService } from '@/services/authService';
import type { IXCLoginRequest, AuthUserData } from '@/types/ixc'; // <--- Tipo Modificado
import AsyncStorage from '@react-native-async-storage/async-storage';

// (O tipo do contexto muda para guardar AuthUserData)
interface AuthContextData {
  isLoading: boolean;
  user: AuthUserData | null; // <--- Tipo Modificado
  signIn: (credentials: IXCLoginRequest) => Promise<void>;
  signOut: () => void;
}
// ...
export const AuthProvider = ({ children }: { children: ReactNode }) => {
  const [user, setUser] = useState<AuthUserData | null>(null); // <--- Tipo Modificado
  // ... (o resto do contexto deve funcionar,
  //      pois o authService.login() agora retorna AuthUserData)
};